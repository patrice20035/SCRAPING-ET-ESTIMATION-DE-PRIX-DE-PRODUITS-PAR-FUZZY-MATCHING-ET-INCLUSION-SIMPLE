#scraping et estimamation par inclusion carrefour

# Importation des modules n√©cessaires
from selenium import webdriver  # Pour automatiser le navigateur web
from selenium.webdriver.common.by import By  # Pour localiser les √©l√©ments sur une page web
import pandas as pd  # Pour manipuler les donn√©es sous forme de DataFrame
import os  # Pour les op√©rations sur les fichiers et dossiers
import time  # Pour g√©rer les temps d'attente
import re  # Pour les expressions r√©guli√®res
import matplotlib.pyplot as plt  # Pour les visualisations (bien que non utilis√© dans ce code)

# Liste des cat√©gories disponibles sur le site Carrefour
CATEGORIES = [
    'bio-et-ecologie', 'fruits-et-legumes', 'viandes-et-poissons', 'pains-et-patisseries',
    'cremerie-et-produits-laitiers', 'charcuterie-et-traiteur', 'surgeles', 'epicerie-salee',
    'epicerie-sucree', 'beaute-et-sante', 'boissons', 'nutrition-et-vegetale', 'hygiene-et-beaute',
    'entretien-et-nettoyage', 'animalerie', 'bebe', 'jardin', 'entretien-de-la-maison',
    'maison-et-decoration', 'cuisine', 'gros-electromenager', 'bricolage',
    'velo-trotinettes-et-loisirs', 'smartphones-et-objets-connectes', 'image-et-son',
    'informatique-et-bureau', 'jeux-videos', 'jeux-et-jouets', 'mode-et-bagagerie'
]

# Dossier de sortie o√π seront enregistr√©s les fichiers CSV et Excel
OUTPUT_FOLDER = r"C:/Users/DELL/OneDrive - etu.unistra.fr/Bureau/cours fac/PROGRAMMATION PYTHON/PROJET/Output"
os.makedirs(OUTPUT_FOLDER, exist_ok=True)  # Cr√©e le dossier s'il n'existe pas d√©j√†

# Demander √† l'utilisateur ce qu'il veut scraper
mode = input("Souhaitez-vous scraper des promotions, des produits, ou estimer un prix ? [promotions/products/estimate] : ").strip().lower()
# V√©rification que le mode saisi est valide
while mode not in ["promotions", "products", "estimate"]:
    mode = input("Veuillez entrer 'promotions', 'products', ou 'estimate' : ").strip().lower()

# Si l'utilisateur a choisi de scraper des produits, afficher les cat√©gories disponibles
if mode == "products":
    print("Voici les cat√©gories disponibles :")
    for idx, cat in enumerate(CATEGORIES, 1):  # Affiche chaque cat√©gorie avec un num√©ro
        print(f" {idx}. {cat}")
    # Demander √† l'utilisateur de choisir une cat√©gorie
    while True:
        try:
            cat_choice = int(input("Choisissez le num√©ro de la cat√©gorie : ").strip())
            if 1 <= cat_choice <= len(CATEGORIES):  # V√©rifie que le num√©ro est valide
                categorie = CATEGORIES[cat_choice - 1]  # R√©cup√®re la cat√©gorie correspondante
                break
            else:
                print("Num√©ro invalide. R√©essayez.")
        except ValueError:  # G√®re les erreurs si l'utilisateur n'entre pas un nombre
            print("Veuillez entrer un num√©ro valide.")
else:
    categorie = None  # Si ce n'est pas le mode 'products', la cat√©gorie reste None

# Fonction pour scraper les promotions sur une seule page
def scrap_single_page_promotions():
    driver = webdriver.Chrome()  # Initialise le navigateur Chrome
    page = 0  # Commence √† la page 0
    all_data = []  # Liste pour stocker toutes les donn√©es
    while True:
        # Charge la page des promotions avec le num√©ro de page
        driver.get(f"https://www.carrefour.fr/promotions?noRedirect=1&page={page}")
        time.sleep(5)  # Attend 5 secondes pour le chargement de la page
        # Trouve tous les √©l√©ments de produits sur la page
        products = driver.find_elements(By.CLASS_NAME, "product-list-grid__item")
        if not products:  # Si aucun produit n'est trouv√©, sort de la boucle
            break

        data = []  # Liste pour stocker les donn√©es de la page courante
        for p in products:  # Parcourt chaque produit
            try:
                # R√©cup√®re le nom du produit
                name = p.find_element(By.CSS_SELECTOR, "a.product-card-title").text
            except:
                name = None  # Si le nom n'est pas trouv√©

            price = None
            old_price = None
            try:
                # R√©cup√®re le prix actuel
                price_block = p.find_element(By.CSS_SELECTOR, "div.product-price__amount--main")
                price_text = price_block.text
                # Nettoie le texte du prix (enl√®ve les caract√®res non num√©riques)
                clean_price = re.sub(r'[^\d,\.]', '', price_text)
                price = float(clean_price.replace(',', '.'))  # Convertit en float
            except:
                pass  # Si le prix n'est pas trouv√©

            try:
                # R√©cup√®re l'ancien prix
                old_price_block = p.find_element(By.CSS_SELECTOR, "div.product-price__amount--old")
                old_price_text = old_price_block.text
                clean_old_price = re.sub(r'[^\d,\.]', '', old_price_text)
                old_price = float(clean_old_price.replace(',', '.'))  # Convertit en float
            except:
                pass  # Si l'ancien prix n'est pas trouv√©

            try:
                # R√©cup√®re l'unit√© de prix (par kg, par L, etc.)
                unit = p.find_element(By.CSS_SELECTOR, "span.product-list-card-plp-grid__per-unit-label").text
            except:
                unit = None  # Si l'unit√© n'est pas trouv√©e

            try:
                # R√©cup√®re la description de la promotion
                promo_description = p.find_element(By.CSS_SELECTOR, "span.promotion-label-refonte__label").text
            except:
                promo_description = None  # Si la description n'est pas trouv√©e

            try:
                # R√©cup√®re la cat√©gorie du produit
                category = p.find_element(By.CSS_SELECTOR, "span.product-card-category").text
            except:
                category = None  # Si la cat√©gorie n'est pas trouv√©e

            # Ajoute les donn√©es du produit si c'est une promotion valide
            if (price and old_price and price != old_price) or promo_description:
                data.append({
                    "product_name": name,
                    "price": price,
                    "old_price": old_price,
                    "difference": round(old_price - price, 2) if price and old_price else None,  # Calcul de la diff√©rence
                    "percentage_difference": round(((old_price - price) / old_price) * 100, 2) if price and old_price else None,  # Calcul du pourcentage de r√©duction
                    "price_per_unit": unit,
                    "promo_description": promo_description,
                    "category": category,
                    "purchasable": True,  # Indique que le produit est achetable
                    "page": page  # Num√©ro de la page
                })

        all_data.extend(data)  # Ajoute les donn√©es de la page √† la liste globale
        page += 1  # Passe √† la page suivante
    driver.quit()  # Ferme le navigateur
    return pd.DataFrame(all_data)  # Retourne les donn√©es sous forme de DataFrame

# Fonction pour scraper les produits d'une cat√©gorie sur une seule page
def scrap_single_page_products(categorie):
    driver = webdriver.Chrome()  # Initialise le navigateur Chrome
    page = 0  # Commence √† la page 0
    all_data = []  # Liste pour stocker toutes les donn√©es
    while True:
        # Charge la page de la cat√©gorie avec le num√©ro de page
        driver.get(f"https://www.carrefour.fr/r/{categorie}?noRedirect=1&page={page}")
        time.sleep(5)  # Attend 5 secondes pour le chargement de la page
        # Trouve tous les √©l√©ments de produits sur la page
        products = driver.find_elements(By.CLASS_NAME, "product-list-grid__item")
        if not products:  # Si aucun produit n'est trouv√©, sort de la boucle
            break

        data = []  # Liste pour stocker les donn√©es de la page courante
        for p in products:  # Parcourt chaque produit
            try:
                # R√©cup√®re le nom du produit
                name = p.find_element(By.CSS_SELECTOR, "a.product-card-title").text
            except:
                name = None  # Si le nom n'est pas trouv√©

            try:
                # R√©cup√®re le prix du produit
                price_block = p.find_element(By.CSS_SELECTOR, "div.product-price__amount--main")
                parts = price_block.find_elements(By.CSS_SELECTOR, "p.product-price__content")
                price_text = ''.join([part.text for part in parts])  # Combine les parties du prix
                price = float(price_text.replace(',', '.').replace('‚Ç¨', '').strip())  # Convertit en float
            except:
                price = None  # Si le prix n'est pas trouv√©

            try:
                # R√©cup√®re l'unit√© de prix
                unit = p.find_element(By.CSS_SELECTOR, "span.product-list-card-plp-grid__per-unit-label").text
            except:
                unit = None  # Si l'unit√© n'est pas trouv√©e

            # Ajoute les donn√©es du produit
            data.append({
                "product_name": name,
                "price": price,
                "price_per_unit": unit,
                "category": categorie.replace('-', ' ').title(),  # Formate le nom de la cat√©gorie
                "purchasable": True,  # Indique que le produit est achetable
                "page": page  # Num√©ro de la page
            })

        all_data.extend(data)  # Ajoute les donn√©es de la page √† la liste globale
        page += 1  # Passe √† la page suivante
    driver.quit()  # Ferme le navigateur
    return pd.DataFrame(all_data)  # Retourne les donn√©es sous forme de DataFrame

# Fonction pour estimer le prix d'un produit
def estimate_price():
    print("Voici les cat√©gories disponibles :")
    for idx, cat in enumerate(CATEGORIES, 1):  # Affiche les cat√©gories disponibles
        print(f" {idx}. {cat}")
    # Demande √† l'utilisateur de choisir une cat√©gorie
    while True:
        try:
            cat_choice = int(input("Choisissez le num√©ro de la cat√©gorie pour l'estimation : ").strip())
            if 1 <= cat_choice <= len(CATEGORIES):  # V√©rifie que le num√©ro est valide
                categorie = CATEGORIES[cat_choice - 1]  # R√©cup√®re la cat√©gorie correspondante
                break
            else:
                print("Num√©ro invalide. R√©essayez.")
        except ValueError:  # G√®re les erreurs si l'utilisateur n'entre pas un nombre
            print("Veuillez entrer un num√©ro valide.")

    # Demande le nom du produit √† estimer
    produit_cible = input("Saisissez le nom du produit √† estimer : ").strip().lower()
    # Scrape les produits de la cat√©gorie choisie
    df = scrap_single_page_products(categorie)
    if df.empty:  # Si aucun produit n'est trouv√©
        print("‚ö†Ô∏è Aucun produit trouv√© dans cette cat√©gorie.")
        return

    # Calcule la similarit√© entre le produit cible et les produits trouv√©s
    df['similarity'] = df['product_name'].apply(lambda x: produit_cible in x.lower() if pd.notnull(x) else False)
    similaires = df[df['similarity']]  # Filtre les produits similaires

    if similaires.empty:  # Si aucun produit similaire n'est trouv√©
        print("‚ö†Ô∏è Aucun produit similaire trouv√©.")
    else:
        # Calcule les statistiques sur les prix des produits similaires
        prix_moyen = similaires['price'].mean()
        prix_min = similaires['price'].min()
        prix_max = similaires['price'].max()
        print("Produits similaires trouv√©s :")
        print(similaires[['product_name', 'price']])  # Affiche les produits similaires
        print(f"Nombre de produits similaires : {len(similaires)}")
        print(f"Prix estim√© moyen : {prix_moyen:.2f} ‚Ç¨")
        print(f"Prix minimum : {prix_min:.2f} ‚Ç¨, Prix maximum : {prix_max:.2f} ‚Ç¨")


# Ex√©cution principale du script
if mode == "estimate":
    estimate_price()  # Lance la fonction d'estimation de prix
elif mode == "promotions":
    df = scrap_single_page_promotions()  # Scrape les promotions
    filename = "carrefour_promotions_page0.csv"  # Nom du fichier CSV
else:
    df = scrap_single_page_products(categorie)  # Scrape les produits d'une cat√©gorie
    filename = f"carrefour_products_{categorie}_page0.csv"  # Nom du fichier CSV

# Sauvegarde des donn√©es si le mode est 'promotions' ou 'products'
if mode in ["promotions", "products"]:
    csv_path = os.path.join(OUTPUT_FOLDER, filename)  # Chemin complet du fichier CSV
    if not df.empty:  # Si des donn√©es ont √©t√© r√©cup√©r√©es
        df.to_csv(csv_path, index=False)  # Sauvegarde en CSV
        print(f"‚úÖ Fichier CSV enregistr√© : {csv_path}")

        # Export vers Excel avec analyses suppl√©mentaires
        excel_path = csv_path.replace('.csv', '.xlsx')  # Chemin du fichier Excel
        with pd.ExcelWriter(excel_path) as writer:  # Cr√©e un fichier Excel
            df.to_excel(writer, sheet_name='Donn√©es', index=False)  # Ajoute les donn√©es
            if mode == "promotions":
                # Ajoute une analyse des diff√©rences moyennes par cat√©gorie
                if 'category' in df.columns and 'difference' in df.columns:
                    mean_diff = df[df['old_price'].notna()].groupby('category')['difference'].mean().reset_index()
                    mean_diff.to_excel(writer, sheet_name='Moyenne diff√©rences', index=False)
                # Ajoute le nombre de promotions par cat√©gorie
                if 'category' in df.columns:
                    count_promos = df.groupby('category').size().reset_index(name='count_promotions')
                    count_promos.to_excel(writer, sheet_name='Nombre promotions', index=False)
        print(f"üìä Fichier Excel avec analyses enregistr√© : {excel_path}")
        print(df.head())  # Affiche les premi√®res lignes des donn√©es
    else:
        print("‚ö†Ô∏è Aucun produit correspondant aux crit√®res n'a √©t√© trouv√©.")

    # Analyse suppl√©mentaire pour les promotions (non impl√©ment√©e dans ce code)
    if mode == "promotions":
        pass
else:
    print("‚ö†Ô∏è Aucun produit correspondant aux crit√®res n'a √©t√© trouv√©.")
